<!DOCTYPE html><html lang="ko"><head><title>JavaScript Garden</title><meta charset="utf-8"><meta name="description" content="A Guide to JavaScript's Quirks and Flaws."><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]-->
</head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/" title="QSS">qss</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">소개</a></h1><ul></ul></li><li class="nav_object"><h1><a href="#object">객체</a></h1><ul><li><a href="#object.general">객체와 프로퍼티</a></li><li><a href="#object.prototype">Prototype</a></li><li><a href="#object.hasownproperty"><code>hasOwnProperty</code></a></li><li><a href="#object.forinloop"><code>for in</code> Loop</a></li></ul></li><li class="nav_function"><h1><a href="#function">함수</a></h1><ul><li><a href="#function.general">Function Declarations과 Function Expressions</a></li><li><a href="#function.this"><code>this</code></a></li><li><a href="#function.closures">Closure와 Reference</a></li><li><a href="#function.arguments"><code>arguments</code> 객체</a></li><li><a href="#function.constructors">생성자</a></li><li><a href="#function.scopes">Scope과 Namespace</a></li></ul></li><li class="nav_array"><h1><a href="#array">Array</a></h1><ul><li><a href="#array.general">Array Iteration과 프로퍼티</a></li><li><a href="#array.constructor"><code>Array</code> 생성자</a></li></ul></li><li class="nav_types"><h1><a href="#types">타입</a></h1><ul><li><a href="#types.equality">객체 비교하기</a></li><li><a href="#types.typeof"><code>typeof</code></a></li><li><a href="#types.instanceof"><code>instanceof</code></a></li><li><a href="#types.casting">Type Casting</a></li></ul></li><li class="nav_core"><h1><a href="#core">핵심</a></h1><ul><li><a href="#core.eval">왜 <code>eval</code>을 사용하면 안 될까?</a></li><li><a href="#core.undefined"><code>undefined</code>와 <code>null</code></a></li><li><a href="#core.semicolon">쎄미콜론을 자동으로 삽입해준다.</a></li><li><a href="#core.delete"><code>delete</code></a></li></ul></li><li class="nav_other"><h1><a href="#other">기타</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code>과 <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>소개</h1><div><p>JavaScript 언어의 핵심에 대한 내용을 모아 <strong>JavaScript Garden</strong>을 만들어 었다. 이 글이 초보자가 JavaScript 익히면서 자주 겪는 실수, 미묘한 버그, 성능 이슈, 나쁜 습관들 줄일 수 있도록 도와줄 것이다.</p>

<p>JavaScript Garden은 단순히 JavaScript 언어 자체를 설명하려 만들지 않았다. 그래서 이 글에서 설명하는 주제들을 이해하려면 반드시 언어에 대한 기본 지식이 필요하다. 먼저 Mozilla Developer Network에 있는 <a href="https://developer.mozilla.org/en/JavaScript/Guide">문서</a>로 JavaScript 언어를 공부하기 바란다.</p>

<h2>저자들</h2>

<p>이 글은 <a href="http://stackoverflow.com/">Stack Overflow</a>에서 사랑받는 두 사람 <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a>과 <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a>의 작품이다. Ivo Wetzel이 글을 썼고 Zhang Yi jiang이 디자인을 맡았다.</p>

<h2>기여자들</h2>

<ul>
<li><a href="https://github.com/caio">Caio Romão</a> (철자 교정)</li>
<li><a href="https://github.com/blixt">Andreas Blixt</a> (언어 교정)</li>
</ul>

<h2>번역</h2>

<ul>
<li><a href="https://github.com/pismute">박창우</a></li>
</ul>

<h2>호스팅</h2>

<p>JavaScript Garden은 Github에서 호스팅하고 있고 <a href="http://cramerdev.com/">Cramer Development</a>가 <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>에서 미러링해주고 있다.</p>

<h2>저작권</h2>

<p>JavaScript Garden은 <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">MIT license</a>를 따르고 <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>에서 호스팅하고 있다. 문제를 발견하면 <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">이슈를 보고</a>하거나 수정해서 Pull Request를 하라. 아니면 Stack Overflow 채팅 사이트의 <a href="http://chat.stackoverflow.com/rooms/17/javascript">Javascript room</a>에서 우리를 찾으라.</p></div></header><!-- Articles--></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>객체</h1></header><!-- Articles--><article id="object.general"><h2>객체와 프로퍼티</h2><div><p>JavaScript에서 <a href="#core.undefined"><code>null</code></a>과 <a href="#core.undefined"><code>undefined</code></a>를 제외한 모든 것은 객체다.</p>

<pre><code>false.toString() // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1
</code></pre>

<p>숫자 리터럴은 객체가 아니라는 오해가 있는데 단지 JavaScript 파서의 문제일 뿐이다. JavaScript 파서는 숫자에 <em>Dot Notation</em>이 들어가면 오류라고 생각한다.</p>

<pre><code>2.toString(); // SyntaxError가 난다.
</code></pre>

<p>하지만, 숫자를 객체로 인식하는 꼼수가 몇 가지 있다.</p>

<pre><code>2..toString(); // 두 번째 점은 잘 된다.
2 .toString(); // 왼쪽 공백이 있으면 잘 된다.
(2).toString(); // 2를 먼저 해석한다.
</code></pre>

</div><div><h3>Object 타입</h3>

<p>JavaScript 객체는 name/value 쌍으로 된 프로퍼티로 구성되기 때문에 <a href="http://en.wikipedia.org/wiki/Hashmap"><em>Hashmap</em></a>으로도 사용할 수 있다. </p>

<p>객체 리터럴인 Object Notation으로 객체를 만들면 <code>Object.prototype</code>을 상속받고 <a href="#object.hasownproperty">프로퍼티를 하나도 가지지 않은</a> 객체가 만들어진다.</p>

<pre><code>var foo = {}; // 깨끗한 새 객체를 만든다.

// 값이 12인 &#39;test&#39; 프로퍼티가 있는 객체를 만든다.
var bar = {test: 12}; 
</code></pre>

</div><div><h3>프로퍼티</h3>

<p>객체의 프로퍼티는 Dot Notation이나 Square Bracket Notation으로 접근할 수 있다.</p>

<pre><code>var foo = {name: &#39;Kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // works
</code></pre>

<p>&#39;[]&#39;은 프로퍼티를 동적으로 할당할 수 있고 변수 이름 규칙에도 구애받지 않는다. 그렇지만, 두 가지 방법은 근본적으로 서로 똑같다. </p>

</div><div><h3>프로퍼티 삭제</h3>

<p>객체의 프로퍼티는 <code>delete</code>로만 삭제할 수 있다. 프로퍼티에 <code>undefined</code>나 <code>null</code>을 할당하는 것은 프로퍼티를 삭제하는 것이 아니라 프로퍼티에 할당된 <em>value</em>만 지우고 <em>key</em>는 그대로 두는 것이다.</p>

<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}
</code></pre>

<p><code>baz</code>만 제거했기 때문에 <code>bar undefined</code>와 <code>foo null</code>은 출력되고 <code>baz</code>와 관련된 것은 출력되지 않는다.</p>

</div><div><h3>Notation of Keys</h3>

<pre><code>var test = {
    &#39;case&#39;: &#39;I am a keyword, so I must be notated as a string&#39;,
    delete: &#39;I am a keyword, so me too&#39; // SyntaxError가 난다.
};
</code></pre>

<p>프로퍼티의 key에 문자열이나 스트링을 사용할 수 있다. 이 부분도 JavaScript 파서의 설계 오류다. ECMAScript 5 이전에는 <code>SystaxError</code>가 났었다.</p>

<p>이 에러는 <code>delete</code>가 키워드이기 때문에 발생하는 것이다. key를 스트링 리터럴로 정의하면 JavaScript 엔진은 언제나 잘 해석한다.</p></div></article><article id="object.prototype"><h2>Prototype</h2><div><p>Javascript는 클래스 스타일의 상속 모델을 사용하지 않고 <em>프로토타입</em> 스타일의 상속 모델을 사용한다.</p>

<p>&#39;이 점이 JavaScript의 약점이다.&#39;라고 말하는 사람들도 있지만 실제로는 prototypal inheritance 모델이 훨씬 더 강력하다. 왜냐하면, 프로토타입 모델에서 클래스 모델을 흉내 내기는 매우 쉽지만, 반대로 클래스 모델에서 프로토타입 모델을 흉내 내기란 너무 어렵다.</p>

<p>실제로 Prototypal Inheritance 모델을 채용한 언어 중에서 JavaScript만큼 널리 사용되는 언어는 없었기 때문에 너무 늦게 두 모델의 차이점이 정리된 감이 있다.</p>

<p>JavaScript는 <em>프로토타입 체인</em>이라는 것으로 상속을 구현한다.</p>

<aside>
  <p><strong>Note:</strong> 간단히 말해서 <code>Bar.prototype = Foo.prototype</code>은 두 객체가 <strong>하나의 프로토타입</strong>을 공유하는 것이다. 그래서 한 객체의 프로토타입을 변경하면 그 프로토타입 객체를 사용하는 다른 객체에도 영향을 끼친다. 대부분은 나쁜 결과로 이어진다.</p>
</aside>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Foo의 인스턴스를 만들어 Bar의 prototype에 할당한다.
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// Bar function을 생성자로 만들고
Bar.prototype.constructor = Bar;

var test = new Bar() // bar 인스턴스를 만든다.

// 결과적으로 만들어진 프로토타입 체인은 다음과 같다. 
test [instance of Bar]
    Bar.prototype [instance of Foo] 
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* etc. */ }
</code></pre>

<p><code>Bar.prototype</code>과 <code>Foo.prototype</code>을 둘 다 상속받았기 때문에 <code>test</code> 객체는 Foo에 정의한 <code>method</code> 함수에 접근할 수 있다. 프로토타입 체인에 있는 <code>Foo</code> 인스턴스의 <code>value</code> 프로퍼티도 사용할 수 있다. <code>new Bar()</code>를 해도 <code>Foo</code> 인스턴스는 새로 만들어지지 않고 Bar의 prototype에 있는 것을 재사용한다. 그래서 모든 Bar 인스턴스의 <code>value</code> 프로퍼티에 들어 있는 객체는 전부 <strong>같은 객체다</strong>.</p>

<aside>
  <p><strong>Note:</strong> <code>Bar.prototype = Foo</code>라고 하는 것은 <code>Foo</code>의 prototype을 가리키는 것이 아니라 Foo라는 Function의 prototype을 가리키는 것이다. 그래서 프로토타입 체인에 <code>Foo.prototype</code> 대신 <code>Function.prototype</code>이 들어서는 것이기 때문에 <code>method</code> 프로퍼티는 못 찾는다.</p>
</aside>

</div><div><h3>프로토타입 찾기</h3>

<p>객체의 프로퍼티에 접근을 시도하면 JavaScript는 해당 이름의 프로퍼티를 찾을 때까지 위쪽으로 프로토타입 체인을 뒤진다.</p>

<p>체인의 끝까지 찾았는데도(보통은 <code>Object.prototype</code>임) 발견하지 못하면 <a href="#core.undefined">undefined</a>를 반환한다.</p>

</div><div><h3>prototype 프로퍼티</h3>

<p>prototype 프로퍼티는 프로토타입 체인을 만드는 데 사용하고 어떤 거라도 할당할 수 있지만, primitive 값을 할당하면 무시된다.</p>

<pre><code>function Foo() {}
Foo.prototype = 1; // 무시됨
</code></pre>

<p>객체를 할당하면 프로토타입 체인이 동적으로 잘 만들어진다.</p>

</div><div><h3>성능</h3>

<p>성능이 중요한 부분에서는 프로토타입 체인을 따라 프로퍼티를 찾는 것이 부담일 수 있다. 게다가 없는 프로퍼티에 접근하면 항상 프로토타입 체인 전체를 뒤진다.</p>

<p>객체를 <a href="#object.forinloop">Iterate</a>하면 프로토타입 체인에 있는 <strong>모든</strong> 프로퍼티가 나열된다.</p>

</div><div><h3>네이티브 프로토타입의 확장</h3>

<p>JavaScript에서는 <code>Object.prototype</code>같이 네이티브 객체들의 프로토타입도 확장할 수 있지만, 이것도 잘못 설계됐다.</p>

<p>이것을 <a href="http://en.wikipedia.org/wiki/Monkey_patch">Monkey Patching</a>라고 부르는데 <em>캡슐화</em>를 망친다. 굉장히 많이 사용하는 <a href="http://prototypejs.org/">Prototype</a>도 굳이 기본 타입에 표준도 아닌 것들을 추가하는 이유를 아직 설명하지 못하고 있다.</p>

<p>기본 타입을 확장하는 것이 좋을 때도 있다. <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>같이 새 JavaScript 엔진에 추가된 기능을 위한 backport를 만들 때는 유용하다.</p>

</div><div><h3>결론</h3>

<p>Prototypal Inheritance 모델을 사용하는 코드를 작성하기 전에는 이 모델을 완벽하게 이해해야 한다. 프로토타입 체인과 관련된 성능 문제로 고생하지 않으려면 프로토타입 체인의 길이에 주의하고 너무 길지 않게 적당히 끊어줘야 한다. JavaScript의 새 기능에 대한 호환성을 유지하려는 경우를 제외하고 절대로 네이티브 프로토타입을 확장하면 안 된다.</p></div></article><article id="object.hasownproperty"><h2><code>hasOwnProperty</code></h2><div><p>어떤 프로퍼티가 해당 객체 자신의 것인지 아니면 <a href="#object.prototype">프로토타입 체인</a>에 있는 것인지 확인하려면 <code>Object.prototype</code>을 상속받은 <code>hasOwnProperty</code> 메소드를 사용해야 한다. </p>

<aside>
  <p><strong>Note:</strong> 이 메소드로는 프로퍼티의 값이 <code>undefined</code>인지 확인할 수 없다. 프로퍼티가 존재해도 그 값은 <code>undefined</code>일 수 있다. </p>
</aside>

<p>프로토타입 체인을 Traverse 하지 않으려면 <code>hasOwnProperty</code>를 사용하는 방법밖에 없다.</p>

<pre><code>// Object.prototype을 더럽힌다.
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true
</code></pre>

<p>프로퍼티의 존재 여부를 확인하는 방법은 <code>hasOwnProperty</code> 메소드 뿐이다. 이 메소드는 프로토타입 체인의 프로퍼티말고 해당 객체의 프로퍼티만 Iterate할 때 유용하다. 객체 자체의 프로퍼티와 프로토타입 체인 어딘가에 있는 프로퍼티를 골라 주는 다른 방법은 없다.</p>

</div><div><h3><code>hasOwnProperty</code>도 프로퍼티</h3>

<p>JavaScript는 <code>hasOwnProperty</code> 프로퍼티도 보호해주지 않는다. 그래서 객체에 <code>hasOwnProperty</code> 프로퍼티가 있으면 다른 객체의 <code>hasOwnProperty</code> 메소드를 빌려 사용해야 한다.</p>

<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // 항상 false를 반환한다.

// 다른 객체의 hasOwnProperty를 사용하여 foo 객체의 프로퍼티 유무를 확인한다.
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true

// Object에 원래 있는 hasOwnProperty를 사용해도 된다.
Object.prototype.hasOwnProperty.call(obj, &#39;bar&#39;); // true
</code></pre>

</div><div><h3>결론</h3>

<p>객체에 프로퍼티가 있는지 <code>hasOwnProperty</code>로만 확인할 수 있다. <a href="#object.forinloop"><code>for in</code> loop</a>은 항상 <code>hasOwnProperty</code>와 함께 사용해야 한다. 네이티브 객체의 <a href="#object.prototype">프로토타입</a>을 확장하는 사태가 일어나도 안전하게 지켜줄 것이다.</p></div></article><article id="object.forinloop"><h2><code>for in</code> Loop</h2><div><p><code>in</code> 연산자와 마찬가지로 <code>for in</code>도 객체의 프로퍼티뿐만 아니라 프로토타입 체인까지 Traverse 한다.</p>

<aside>
  <p><strong>Note:</strong> <code>for in</code>은 Array의 <code>length</code>처럼 <code>enumerable</code> 속성이 <code>false</code>인 프로퍼티는 Iterate 하지 않는다.</p>
</aside>

<pre><code>// 원래는 Object.prototype을 바꾸면 안 된다.
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // bar와 moo 둘 다 출력한다.
}
</code></pre>

<p>선택적으로 Iterate 하려면 <code>for in</code>은 바꿀 수 없으니까 Loop 바디에서 하는 수밖에 없다. <code>Object.prototype</code>의 <a href="#object.hasownproperty"><code>hasOwnProperty</code></a>메소드를 사용하면 객체의 프로퍼티만 골라낼 수 있다.</p>

<aside>
  <p><strong>Note:</strong> <code>for in</code>은 프로토타입 체인을 모두 Traverse 한다. 그래서 상속할 때마다 더 느려진다.</p>
</aside>

</div><div><h3><code>hasOwnProperty</code>로 필터링 하기</h3>

<pre><code>// 위의 예제에 이어서 
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>실무에 사용할 작정이라면 이렇게 써야 옳다. <code>hasOwnProperty</code> 때문에 <strong>오직</strong> <code>moo</code>만 출력된다. <code>hasOwnProperty</code>가 없으면 <code>Object.prototype</code>같은 네이티브 프로토타입이 확장될 때 에러 날 수 있다.</p>

<p>네이티브 프로토타입을 확장하는 <a href="http://www.prototypejs.org/">Proptotype 라이브러리</a>을 사용하면 <code>hasOwnProperty</code>가 없는 <code>for in</code> Loop은 꼭 문제를 일으킨다.</p>

</div><div><h3>결론</h3>

<p><code>hasOwnProperty</code>는 항상 사용해야 한다. 실제로 코드가 동작할 환경에서 네이티브 프로토타입의 확장 여부에 대해 어떠한 가정도 하지 말아야 한다. </p></div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>함수</h1></header><!-- Articles--><article id="function.general"><h2>Function Declarations과 Function Expressions</h2><div><p>JavaScript의 Function은 First Class Object라서 일반 객체처럼 취급될 수 있다. 그래서 익명 함수를 비동기 함수의 callback 같은 거로 넘길 수 있다.</p>

</div><div><h3><code>function</code> Declaration</h3>

<pre><code>function foo() {}
</code></pre>

<p>코드를 실행하기 전에 이 함수는 <a href="#function.scopes">Hoist</a>되기 때문에 해당 Scope 어디에서나 이 함수를 호출할 수 있다. 심지어 함수를 정의하기 전에 호출해도 된다.</p>

<pre><code>foo(); // 이 코드가 실행되기 전에 foo가 만들어져서 잘 호출된다.
function foo() {}
</code></pre>

</div><div><h3><code>function</code> Expression</h3>

<pre><code>var foo = function() {};
</code></pre>

<p><code>foo</code> 변수에 <em>익명</em> 함수를 할당하는 예를 보자.</p>

<pre><code>foo; // &#39;undefined&#39;
foo(); // TypeError가 난다.
var foo = function() {};
</code></pre>

<p>JavaScript가 Hoist하는 것은 <code>var</code>로 선언하는 부분뿐이기 때문에 코드가 실행하기 전에 <code>foo</code> 변수는 정의된다.</p>

<p>그러나 할당은 런타임에만 가능한 일이라 할당하는 코드가 실행될 때까지 <code>foo</code>변수는 기본 값인 <a href="#core.undefined">undefined</a>다.</p>

</div><div><h3>Named Function Expression</h3>

<p>Named Function을 할당하는 경우는 조금 특이하다.</p>

<pre><code>var foo = function bar() {
    bar(); // 된다.
}
bar(); // ReferenceError
</code></pre>

<p>함수 밖에서는 <code>bar</code>를 사용할 수 없지만, 함수 안에서는 사용할 수 있다. JavaScript가 <a href="#function.scopes">이름을 찾는 방법</a>이 있는데 function Scope에서는 항상 그 함수의 이름을 사용할 수 있다.</p></div></article><article id="function.this"><h2><code>this</code></h2><div><p>다른 프로그래밍 언어에서 <code>this</code>가 가리키는 것과 JavaScript에서 <code>this</code>가 가리키는 것과는 좀 다르다. <code>this</code>가 가리킬 수 있는 객체는 정확히 5종류나 된다.</p>

</div><div><h3>Global Scope에서</h3>

<pre><code>this;
</code></pre>

<p>Global Scope에서도 this가 사용될 수 있고 이때에는 <em>Global</em> 객체를 가리킨다.</p>

</div><div><h3>함수를 호출할 때</h3>

<pre><code>foo();
</code></pre>

<p>이때에도 <code>this</code>는 <em>Global</em> 객체를 가리킨다.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> strict 모드에서 더는 Global 객체를 가리키지 않고 대신 <code>undefined</code>를 가리킨다.</p>
</aside>

</div><div><h3>메소드로 호출할 때</h3>

<pre><code>test.foo(); 
</code></pre>

<p>이 경우에는 <code>this</code>가 <code>test</code>를 가리킨다.</p>

</div><div><h3>생성자를 호출할 때</h3>

<pre><code>new foo(); 
</code></pre>

<p><code>new</code> 키워드로 <a href="#function.constructors">생성자</a>를 실행시키는 경우에 이 생성자 안에서 <code>this</code>는 새로 만들어진 객체를 가리킨다.</p>

</div><div><h3><code>this</code>가 가리키는 객체 정해주기.</h3>

<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // a = 1, b = 2, c = 3으로 넘어간다.
foo.call(bar, 1, 2, 3); // 이것도... 
</code></pre>

<p><code>Function.prototype</code>의 <code>call</code>이나 <code>apply</code> 메소드를 호출하면 <code>this</code>가 무엇을 가리킬지 <em>정해줄 수 있다</em>. 호출할 때 첫 번째 인자로 <code>this</code>가 가리켜야 할 객체를 넘겨준다.</p>

<p>그래서 <code>foo</code> Function 안에서 <code>this</code>는 위에서 설명했던 객체 중 하나를 가리키는 것이 아니라 <code>bar</code>를 가리킨다.</p>

<aside>
  <p><strong>Note:</strong> 객체 리터럴에서 this는 그 객체를 가리키지 않는다. 예를 들어 <code>var obj= {me:this}</code>에서 <code>me</code>가 <code>obj</code>를 가리키는 것이 아니라 위에 설명한 5가지 객체 중 하나를 가리킨다.</p>
</aside>

</div><div><h3>대표적인 결점</h3>

<p><code>this</code>가 Global 객체를 가리키는 것도 잘못 설계된 부분 중 하나다. 괜찮아 보이지만 실제로는 전혀 사용하지 않는다.</p>

<pre><code>Foo.method = function() {
    function test() {
        // 여기에서 this는 Global 객체를 가리킨다.
    }
    test();
}
</code></pre>

<p><code>test</code> 에서 <code>this</code>가 <code>Foo</code>를 가리킬 것으로 생각할 테지만 틀렸다. 실제로는 그렇지 않다.</p>

<p><code>test</code>에서 <code>Foo</code>에 접근하려면 method에 Local 변수를 하나 만들고 <code>Foo</code>를 가리키게 하여야 한다.</p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // 여기에서 this 대신에 that을 사용하여 Foo에 접근한다.
    }
    test();
}
</code></pre>

<p><code>that</code>은 this에 접근하기 위해 만든 변수다. <a href="#function.closures">closures</a>와 함께 <code>this</code>의 값을 넘기는 데 사용할 수 있다.</p>

</div><div><h3>Method할당 하기</h3>

<p>메소드를 변수에 <em>할당</em>해 버리기 때문에 Function Aliasing은 JavaScript에서 안된다.</p>

<pre><code>var test = someObject.methodTest;
test();
</code></pre>

<p><code>test</code>는 다른 함수를 호출하는 것과 다름없어서 <code>this</code>가 someObject를 가리키지 않는다.</p>

<p>처음에는 <code>this</code>를 늦게 바인딩하는 것이 나쁜 아이디어라고 생각할 수도 있지만, 이 점이 실제로 <a href="#object.prototype">prototypal inheritance</a>를 가능케 해준다.</p>

<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
</code></pre>

<p><code>Bar</code> 인스턴스에서 <code>method</code>를 호출하면 <code>method</code>에서 <code>this</code>는 바로 그 인스턴스를 가리킨다.</p></div></article><article id="function.closures"><h2>Closure와 Reference</h2><div><p><em>Closure</em>는 JavaScript의 특장점 중 하나다. Closure에서는 그 Closure를 만든 외부 Scope에 접근할 있다. JavaScript에서 Scope을 만들려면 <a href="#function.scopes">Function Scope</a>을 사용하는 방법밖에 없기 때문에 Closure는 함수로 만든다.</p>

</div><div><h3>private 변수</h3>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p><code>Counter</code>는 <code>increment</code> Closure와 <code>get</code> Closure 두 개를 반환한다. 이 두 Closure는 <code>Counter</code> Scope에 대한 <strong>reference</strong>를 유지하고 있기 때문에 그 Scope에 있는 count 변수에 계속 접근할 수 있다.</p>

</div><div><h3>Private 변수가 진짜 맞나?</h3>

<p>JavaScript에서 Scope을 어딘가에 할당하거나 저장해두는 것이 불가능하다. 그래서 Scope 밖에서는 count 변수에 직접 접근할 수 없다. 꼭 Scope 안에서 정의한 두 closure를 통해서만 접근할 수 있다.</p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>이 코드의 count는 <code>Counter</code> Scope의 변수 count가 아니다. <code>foo.hack</code>은 그 Scope 안에 정의되지 않았기 때문에 이 <code>count</code>는 <em>Global</em> 변수를 사용하는 것이다.</p>

</div><div><h3>Loop에서 Closure 사용하기</h3>

<p>많은 사람은 Loop에서 Closure를 사용할 때 자주 index 변수를 잘못 사용한다.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>

<p>이 코드는 <code>0</code>부터 <code>9</code>까지의 수를 출력하지 않고 <code>10</code>만 열 번 출력한다.</p>

<p>이 <em>Anonymous</em> Function은 변수 <code>i</code>에 대한 참조를 저장했다가 <code>console.log</code>가 호출되는 시점에 <code>i</code>의 값을 사용한다. <code>console.log</code>가 호출되는 시점은 <code>for loop</code>이 이미 끝난 상태라서 <code>i</code> 값은 10이다.</p>

<p>기대한 결과를 얻으려면 <code>i</code> 값을 복사해 두어야 한다.</p>

</div><div><h3>이 Reference 문제 해결하기</h3>

<p><a href="#function.scopes">Anonymous Wrapper</a>로 index 값을 복사하는 것이 좋다.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>

<p>이 Anonymous Function의 인자로 <code>i</code>를 넘기면 이 함수의 파라미터 e에 i의 <strong>값</strong>이 복사된다.</p>

<p>이 <code>setTimeout</code>는 anonymous function 파라미터인 <code>e</code>에 대한 참조를 갖게 되고 <code>e</code>는 loop의 상태에 따라 변하지 않는다.</p>

<p>함수를 반환하는 Anonymous Wrapper를 이용하는 방법도 있다. 다음 코드는 위 코드와 같다.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
</code></pre></div></article><article id="function.arguments"><h2><code>arguments</code> 객체</h2><div><p>JavaScript의 모든 Function Scope에는 <code>arguments</code>라는 특별한 변수가 있다. 이 변수는 Function에 넘겨진 모든 인자에 대한 정보가 담겨 있다.</p>

<aside>
  <p><strong>Note:</strong> <code>arguments</code> 변수는 Function 안에서 다시 정의할 수 없다. <code>var</code> 구문이나 파라미터에 <code>arguments</code>라는 이름으로 변수를 정의해도 변수가 재정의되지 않는다.</p>
</aside>

<p><code>length</code> 프로퍼티도 있는 데다가 여러모로 Array와 비슷하게 생겼지만 Array.prototype을 상속받지 않았다. <code>arguments</code> 객체는 <code>Array</code>가 아니다. </p>

<p>그래서 <code>arguments</code>에는 <code>push</code>, <code>pop</code>, <code>slice</code> 같은 표준 메소드가 없다. <code>for</code>로 하는 Iteration은 원래 잘되지만 <code>Array</code>의 메소드를 이용하려면 <code>arguments</code>를 Array로 변환해야 한다.</p>

</div><div><h3>Array로 변환하기</h3>

<p>다음 코드는 arguments에 있는 객체를 새로운 Array에 담아 반환한다.</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>이 변환 과정은 <strong>느리기</strong> 때문에 성능이 중요한 부분에 사용하는 것은 <strong>별로 바람직하지</strong> 못 하다.</p>

</div><div><h3>arguemnts 객체 넘기기</h3>

<p>어떤 Function에서 다른 Function로 arguments 객체를 넘길 때에는 다음과 같이 하는 것이 좋다.</p>

<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // 내곡동에 땅이라도 산다.
}
</code></pre>

<p><code>call</code>과 <code>apply</code>를 함께 사용하여 unbound wrapper도 쉽게 만들 수 있다.</p>

<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// "method"의 unbound 버전
// 이 Function의 인자: this, arg1, arg2...argN
Foo.method = function() {

    // 결과: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};
</code></pre>

</div><div><h3>파라미터와 arguments 객체 인덱스</h3>

<p>파라미터와 <code>arguments</code> 객체의 프로퍼티는 모두 <em>getter</em>와 <em>setter</em>를 가진다.</p>

<p>그래서 파라미터나 <code>arguments</code> 객체의 프로퍼티의 값을 바꾸면 둘 다 바뀐다.</p>

<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);
</code></pre>

</div><div><h3>성능에 대한 진실과 오해.</h3>

<p><code>arguments</code> 객체는 항상 만들어 지지만 예외도 있다. <code>arguments</code>라는 이름의 변수를 Function 안에 정의하거나 그 이름으로 파라미터를 만들면 <code>arguemnts</code> 객체는 만들어지지 않는다. 그렇지만, 이럴때는 어차피 안쓰겠다는 의미니까 상관 없다.</p>

<p>그리고 <em>getter</em>와 <em>setter</em>는 항상 생성되기 때문에 getter/setter를 사용하는 것은 성능에 별 영향을 끼치지 않는다. 예제처럼 단순한 코드가 아니라 <code>arguments</code> 객체를 다방면으로 활용하는 실제 코드에서도 마찬가지다.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> strict 모드에서는 <em>getter</em>와 <em>setter</em>가 생성되지 않는다.</p>
</aside>

<p>그러나 예외도 있다. 최신 JavaScript 엔진에서 <code>arguments.callee</code>를 사용하면 성능이 확 떨어진다.</p>

<pre><code>function foo() {
    arguments.callee; // 이 Function를 가리킨다.
    arguments.callee.caller; // 이 Function를 호출한 Function를 가리킨다.
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // 원래 인라인 돼야 하는디...
    }
}
</code></pre>

<p>이 코드에서 Callee와 Caller를 알아야 하기 때문에 <code>foo</code>는 더는 <a href="http://en.wikipedia.org/wiki/Inlining">인라인</a>하지 않는다. 이렇게 쓰면 인라인이 주는 성능상 장점을 포기해야 하는데다가 Function이 호출되는 상황(calling context)에 의존하게 돼 버려서 Encapsulation도 해친다.</p>

<p><code>arguments.callee</code>와 그 프로퍼티들은 <strong>절대</strong> 사용하지 말아야 한다.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> strict 모드에서 <code>arguments.callee</code>는 deprecated됐기 때문에 사용하면 <code>TypeError</code>가 난다.</p>
</aside></div></article><article id="function.constructors"><h2>생성자</h2><div><p>JavaScript에서 생성자는 다른 언어들과 다르게 <code>new</code> 키워드로 호출되는 함수가 생성자다.</p>

<p>어쨌든 생성자로 호출된 함수의 this는 막 만들어진 객체를 참조한다. <strong>막 만든</strong> 객체의 <a href="#object.prototype">prototype</a>에는 생성자의 prototype이 할당된다.</p>

<p>생성자에 <code>return</code> 구문이 없으면 this가 가리키는 객체를 반환한다.</p>

<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p><code>new</code> 키워드가 실행되는 시점에 <code>Foo</code>를 생성자로 호출하고 <code>Foo.prototype</code>을 새 객체의 prototype에 할당한다.</p>

<p>생성자에 <code>return</code> 구문이 있고 literal이 아니라 <code>객체</code>를 반환하면 그 객체가 반환된다.</p>

<pre><code>function Bar() {
    return 2;
}
new Bar(); // 새 객체를 만들어 반환

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // 명시한 객체를 반환
</code></pre>

<p>new 키워드가 없으면 그 함수는 객체를 반환하지 않는다.</p>

<pre><code>function Foo() {
    this.bla = 1; // gets set on the global object
}
Foo(); // undefined
</code></pre>

<p>이 함수는 그때그때 다르게 동작하지만 보통 <a href="#function.this"><code>this</code></a>의 규칙에 따라 <code>this</code>의 값으로 <em>Global 객체</em>가 사용된다.:w</p>

</div><div><h3>팩토리</h3>

<p>생성자가 객체를 반환하면 <code>new</code> 키워드를 생략할 수 있다.</p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();
</code></pre>

<p>new 키워드가 있으나 없으니 <code>Bar</code> 생성자는 똑같이 동작한다. <a href="#function.closures">Closure</a>가 할당된 method 프로퍼티가 있는 객체를 만들어 반환한다.</p>

<p><code>new Bar()</code>는 반환된 객체의 prototype 프로퍼티에 아무런 영향을 주지 않는다. 객체를 반환하지 않는 생성자로 만들어지는 경우에만 객체의 prototype이 생성자의 것으로 할당된다.</p>

<p>그러니까 이 예제에서 <code>new</code> 키워드의 유무는 아무 차이가 없다.</p>

</div><div><h3>팩토리로 객체 만들기</h3>

<p><code>new</code> 키워드를 빼먹었을 때 버그가 생긴다는 이유로 <strong>아예 new를 사용하지 말 것</strong>을 권하기도 한다.</p>

<p>객체를 만들고 반환해주는 팩토리를 사용하여 <code>new</code> 키워드 문제를 회피할 수 있다.</p>

<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}
</code></pre>

<p><code>new</code> 키워드가 없어도 괜찮고 <a href="#function.closures">private 변수</a>를 사용하기도 쉽다. 그렇지만, 단점도 있다.</p>

<ol>
<li>prototype으로 메소드를 공유하지 않으므로 메모리를 좀 더 사용한다.</li>
<li>팩토리를 상속하려면 모든 메소드를 복사하거나 객체의 prototype에 객체를 할당해 주어야 한다.</li>
<li><code>new</code> 키워드를 누락시켜서 prototype chain을 끊어버리는 것은 아무래도 언어의 의도에 어긋난다.</li>
</ol>

</div><div><h3>결론</h3>

<p><code>new</code> 키워드가 생략되면 버그가 생길 수 있지만 그렇다고 prototype을 사용하지 않을 이유가 되지 않는다. 애플리케이션에 맞는 방법을 선택하는 것이 나을 거고 어떤 방법이든 <em>*엄격하고 한결같이</em> 지켜야 한다.</p></div></article><article id="function.scopes"><h2>Scope과 Namespace</h2><div><p>JavaScript는 &#39;{}&#39; Block이 배배 꼬여 있어도 문법적으로는 잘 처리하지만, Block Scope은 지원하지 않는다. 그래서 JavaScript에서는 항상 <em>Function Scope</em>을 사용한다.</p>

<pre><code>function test() { // Scope
    for(var i = 0; i &lt; 10; i++) { // Scope이 아님
        // count
    }
    console.log(i); // 10
}
</code></pre>

<aside>
  <p><strong>Note:</strong> 할당할 때, 반환할 때, Function 인자에서 사용되는 것을 제외하면 <code>{...}</code>는 모두 객체 리터럴이 아니라 Block 구문으로 해석된다. 그래서 <a href="#core.semicolon">세미콜론을 자동으로 넣어주면</a> 에러가 생길 수 있다.</p>
</aside>

<p>그리고 JavaScript에는 Namepspace 개념이 없어서 <em>항상 공유하는</em> namepace가 딱 하나다.</p>

<p>변수를 사용할 때마다 JavaScript는 아는 Scope을 상위 방향으로 찾는다. Global Scope에까지 해당 변수를 찾지 못하면 <code>ReferenceError</code>가 난다.</p>

</div><div><h3>Global 변수 지옥.</h3>

<pre><code>// script A
foo = &#39;42&#39;;

// script B
var foo = &#39;42&#39;
</code></pre>

<p>이 두 스크립트는 전혀 다르다. Script A는 <em>Global</em> Scope에 <code>foo</code>라는 변수를 정의하는 것이고 Script B는 <em>현</em> Scope에 변수 <code>foo</code>를 정의하는 것이다.</p>

<p>다시 말하지만, 이 둘은 전혀 다르고 <code>var</code>가 없을 때 특별한 의미가 있다.</p>

<pre><code>// Global Scope
var foo = 42;
function test() {
    // local Scope
    foo = 21;
}
test();
foo; // 21
</code></pre>

<p>Function에서 <code>var</code> 구문을 빼버리면 Global Scope의 <code>foo</code>의 값을 바꿔버린다. &#39;뭐 이게 뭐가 문제야&#39;라고 생각될 수 있지만 수천 줄인 JavaScript 코드에서 <code>var</code>를 빼먹어서 생긴 버그를 해결하는 것은 정말 어렵다.</p>

<pre><code>// Global Scope
var items = [/* some list */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // Scope of subLoop
    for(i = 0; i &lt; 10; i++) { // var가 없다.
        // 내가 for문도 해봐서 아는데...
    }
}
</code></pre>

<p>subLoop이 Global 변수 <code>i</code>의 값을 변경해버리기 때문에 외부 Loop은 <code>subLoop</code>을 한번 호출하고 나면 종료된다. 두 번째 <code>for</code> Loop에 <code>var</code>를 사용하여 <code>i</code>를 정의하면 이 문제는 생기지 않는다. 외부 Scope의 변수를 사용하는 것이 아니라면 <code>var</code>를 꼭 넣어야 한다.</p>

</div><div><h3>Local 변수</h3>

<p>JavaScript에서 Local 변수는 <a href="#function.general">Function 파라미터</a>와 <code>var</code>로 정의한 변수뿐이다.</p>

<pre><code>// Global Scope
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // test Function의 local Scope
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);
</code></pre>

<p><code>foo</code>, <code>i</code>는 <code>test</code> Function Scope에 있는 Local 변수라서 Global의 <code>foo</code>, <code>i</code> 값은 바뀌지 않는다. 하지만 <code>bar</code>는 Global 변수이기 때문에 Global의 <code>bar</code> 값이 변경된다.</p>

</div><div><h3>Hoisting</h3>

<p>JavaScript는 선언문을 모두 <strong>Hoist</strong>한다. Hoist는 <code>var</code> 구문이나 <code>function</code>을 선언문을 해당 Scope의 가장 처음으로 옮기는 것을 말한다.</p>

<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}
</code></pre>

<p>코드를 본격적으로 실행하기 전에 JavaScript는 <code>var</code> 구문과 <code>function</code> 선언문을 해당 Scope의 상위로 옮긴다.</p>

<pre><code>// var 구문이 여기로 옮겨짐.
var bar, someValue; // default to &#39;undefined&#39;

// function 선언문도 여기로 옮겨짐
function test(data) {
    var goo, i, e; // Block Scope은 없으므로 local 변수들은 여기로 옮겨짐
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // bar()가 아직 &#39;undefined&#39;이기 때문에 TypeError가 남
someValue = 42; // Hoisting은 할당문까지 옮기지 않는다.
bar = function() {};

test();
</code></pre>

<p>Block Scope이 없으므로 Loop이나 if의 Block 안에 있는 <code>var</code> 구문들까지도 모두 Function Scope의 앞쪽으로 옮겨진다. 그래서 <code>if</code> Block의 결과는 좀 이상해진다.</p>

<p>원래 코드에서 <code>if</code> Block은 <em>Global 변수</em> <code>goo</code>를 바꾸는 것처럼 보였지만 Hoisting 후에는 <em>local 변수</em>를 바꾼다.</p>

<p><em>Hoisting</em>을 모르면 다음과 같은 코드는 <code>ReferenceError</code>를 낼 것으로 생각할 것이다.</p>

<pre><code>// SomeImportantThing이 초기화됐는지 검사한다.
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>

<p><code>var</code> 구문은 <em>Global Scope</em> 상단으로 옮겨지기 때문에 이 코드는 잘 동작한다.</p>

<pre><code>var SomeImportantThing;

// SomeImportantThing을 여기서 초기화하거나 말거나...

// SomeImportantThing는 선언돼 있다.
if (!SomeImportantThing) {
    SomeImportantThing = {};
}
</code></pre>

</div><div><h3>이름 찾는 순서</h3>

<p>JavaScript의 모든 Scope은 <em>현 객체</em>를 가리키는 <a href="#function.this"><code>this</code></a>를 가지고 있다. <em>Global Scope</em>에도 this가 있다.</p>

<p>Function Scope에는 <a href="#function.arguments"><code>arguments</code></a>라는 변수가 하나 더 있다. 이 변수는 Function에 넘겨진 인자들이 담겨 있다.</p>

<p>예를 들어 Function Scope에서 <code>foo</code>라는 변수에 접근할 때 JavaScript는 다음과 같은 순서로 찾는다.</p>

<ol>
<li>해당 Scope에서 <code>var foo</code> 구문으로 선언된 것을 찾는다.</li>
<li>Function 파라미터에서 <code>foo</code>라는 것을 찾는다.</li>
<li>해당 Function 이름이 <code>foo</code>인지 찾는다.</li>
<li>상위 Scope으로 있는지 확인하고 있으면 <strong>#1</strong>부터 다시 한다.</li>
</ol>

<aside>
  <p><strong>Note:</strong> <code>arguments</code>라는 파라미터가 있으면 Function의 기본 객체인 <code>arguments</code>가 생성되지 않는다.</p>
</aside>

</div><div><h3>Namespace</h3>

<p>JavaScript에서는 Global Namepspace 하나밖에 없어서 변수 이름이 중복되기 쉽다. 하지만 <em>Anonymous Wrappers</em>가 있어서 쉽게 피해갈 수 있다.</p>

<pre><code>(function() {
    // 일종의 Namepspace라고 할 수 있다.

    window.foo = function() {
        // 이 Closure는 Global Scope에 노출된다.
    };

})(); // Function를 정의하자마자 실행한다.
</code></pre>

<p>Unnamed Function은 <a href="#function.general">expressions</a>이기 때문에 호출되려면 먼저 Evaluate돼야 한다.</p>

<pre><code>( // 소괄호 안에 있는 것을 먼저 Evaluate한다.
function() {}
) // 그리고 Function 객체를 반환한다.
() // Evaluation된 결과를 호출한다.
</code></pre>

<p>Function을 Evaluate하고 바로 호출하는 방법이 몇가지 더 있다. 문법은 다르지만 똑같다.</p>

<pre><code>// Fucntion을 Evaluate하자마자 호출하는 방법들...
!function(){}();
+function(){}();
(function(){}());
// 등등...
</code></pre>

</div><div><h3>결론</h3>

<p>코드를 캡슐화할 때는 늘 <em>Anonymous Wrapper</em>로 Namepspace를 만들어 사용해야 한다. 이 Wrapper는 이름이 중복되는 것을 막아 주고 더 쉽게 모듈화할 수 있도록 해준다.</p>

<p>그리고 Global 변수를 사용하는 것은 악질적인 습관이다. 이유야 어쨌든 에러 나기 쉽고 관리하기도 어렵다.</p></div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Array</h1></header><!-- Articles--><article id="array.general"><h2>Array Iteration과 프로퍼티</h2><div><p>JavaScript에서는 Array도 객체 Iterate를 할 때 <a href="#object.forinloop"><code>for in</code></a>을 사용해서 좋을 게 없다. 실제로 Array에 <code>for in</code>을 사용하지 말아야 할 근거가 매우 많다.</p>

<aside>
  <p><strong>Note:</strong> JavaScript의 Array는 <em>Associative Array</em>가 <strong>아니다</strong>. JavaScript <a href="#object.general">객체</a>는 key/value만 Mapping할 뿐이다. Associative Array는 순서를 보장하지만, 객체는 보장하지 않는다.</p>
</aside>

<p><code>for in</code>은 프로토타입 체인에 있는 프로퍼티를 모두 훑는(enumerate) 데다가 객체 자신의 프로퍼티만 훑으려면 <a href="#object.hasownproperty"><code>hasOwnProperty</code></a>를 사용해야 하기 때문에 <code>for</code>보다 20배 느리다.</p>

</div><div><h3>Iteration</h3>

<p>Array를 Iterate할 때에는 구식인 <code>for</code>를 사용하는 것이 가장 빠르다.</p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>이 예제에서 <code>l = list.length</code>로 Array의 length 값을 캐시해야 한다는 것을 꼭 기억해야 한다.</p>

<p>매 Iterate마다 Array에 있는 <code>length</code> 프로퍼티에 접근하는 것은 좀 부담스럽다. 최신 JavaScript 엔진은 이 일을 알아서 처리해주기도 하지만 코드가 늘 새 엔진에서 실행되도록 보장할 방법이 없다.</p>

<p>실제로 캐시 하지 않으면 성능이 반으로 줄어든다.</p>

</div><div><h3><code>length</code> 프로퍼티</h3>

<p><code>length</code> 프로퍼티의 <em>getter</em>는 단순히 Array 안에 있는 엘리먼트의 개수를 반환하고 <em>setter</em>는 Array를 할당한 수만큼 잘라 버린다.</p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo; // [1, 2, 3]
</code></pre>

<p>현재 크기보다 더 작은 값을 할당하면 Array를 자르지만, 현재 크기보다 더 큰 값을 할당한다고 해서 Array를 늘리지 않는다.</p>

</div><div><h3>결론</h3>

<p>최적의 성능을 위해서는 <code>for</code>를 사용하고 <code>length</code> 프로퍼티 값을 캐시해야 한다. Array에 <code>for in</code>을 사용하면 성능도 떨어지고 버그 나기도 쉽다.</p></div></article><article id="array.constructor"><h2><code>Array</code> 생성자</h2><div><p><code>Array</code> 생성자가 파라미터를 처리하는 방법은 모호하다. 그래서 항상 <code>[]</code> 노테이션으로 Array를 만들어야 한다.</p>

<pre><code>[1, 2, 3]; // Result: [1, 2, 3]
new Array(1, 2, 3); // Result: [1, 2, 3]

[3]; // Result: [3]
new Array(3); // Result: []
new Array(&#39;3&#39;) // Result: [&#39;3&#39;]
</code></pre>

<p><code>Array</code> 생성자에 인자로 숫자를 넘기면 <code>length</code>가 그 숫자인 텅 빈 <code>Array</code> 하나를 반환된다. 생성자는 <strong>오직</strong> <code>length</code> 프로퍼티에 그 숫자를 할당하기만 하고 <code>Array</code>는 실제로 초기화하지 않는다.</p>

<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // false, 이 인덱스는 초기화되지 않음.
</code></pre>

<p>Array의 length 프로퍼티에 숫자를 할당해주는 이 기능이 유용할 때도 있긴 있다. <code>for loop</code>을 사용하지 않고 스트링을 더할 때가 그렇다.</p>

<pre><code>new Array(count + 1).join(stringToRepeat);
</code></pre>

</div><div><h3>결론</h3>

<p><code>Array</code> 생성자는 가능하면 사용하지 말아야 한다. <code>[]</code> 노테이션이 더 알맞다. 더 간략하고 명확하기 때문에 보기도 좋다.</p></div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>타입</h1></header><!-- Articles--><article id="types.equality"><h2>객체 비교하기</h2><div><p>JavaScript에서 객체를 비교하는 방법은 두 가지다.</p>

</div><div><h3>Equality Operator</h3>

<p><code>==</code>가 Equality Operator이다.</p>

<p>JavaScript는 Weak Typing을 따르기 때문에 equality operator가 비교할 때 두 객체의 자료형을 <strong>강제로</strong> 변환한다.</p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>이 표는 왜 Equality Operator를 사용하면 안 되는지를 보여준다. 이 복잡한 변환 규칙은 실제로 골치 아픈 버그를 만들어 낸다.</p>

<p>게다가 강제로 타입을 변환하는 것은 성능 문제도 일으킨다. 예를 들어 스트링과 숫자를 비교하려면 반드시 숫자로 변환해야 한다.</p>

</div><div><h3>Strict Equality Operator</h3>

<p>Strict Equality Operator는 <code>===</code>이다.</p>

<p>강제로 타입을 변환하지 않는 것을 제외하고는 Equality Operator와 똑같다.</p>

<pre><code>""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
" \t\r\n"    ===   0             // false
</code></pre>

<p>이 결과가 훨씬 명확하고 문제를 빨리 발견할 수 있게 해준다. 이 Operator를 사용하면 코드가 좀 더 튼튼하고 비교하는 두 객체의 타입이 다르면 성능도 빠르다.</p>

</div><div><h3>객체 비교하기</h3>

<p><code>==</code>와 <code>===</code>는 둘 다 <strong>Equality</strong> Operator지만 비교하는 객체 중 적어도 한 개가 Object 타입일 때에는 다르게 동작한다.</p>

<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true
</code></pre>

<p>두 Operator 모두 <strong>같은 객체(identity)</strong>인지 비교하는 것이지 객체의 값이 같은지 비교하는 것이 아니다. C에서 포인터를 비교하거나 Python의 is처럼 같은 인스턴스인지 비교하는 것이다.</p>

</div><div><h3>결론</h3>

<p>반드시 <strong>Strict Equality Operator</strong>를 사용해야 한다. 비교하기 위해서 꼭 타입 변환이 필요하면 언어의 복잡한 변환 규칙에 맡기지 말고 꼭 명시적으로 변환하고 나서 비교해야 한다.</p></div></article><article id="types.typeof"><h2><code>typeof</code></h2><div><p><code>typeof</code>도 <a href="#types.instanceof"><code>instanceof</code></a>와 함께 JavaScript에서 치명적으로 잘못 설계된 부분이다. 이건 정말 아무짝에 쓸모없다.</p>

<p><code>instanceof</code>는 그래도 쓸 데가 좀 있었는데 <code>typeof</code>는 딱 한 군데에만 써먹을 수 있다. 객체의 타입을 검사할 일이 없다.</p>

<aside>
  <p><strong>Note:</strong> <code>typeof</code>는 함수처럼 <code>typeof(obj)</code>로 사용할 수 있다. 하지만, 이것은 함수를 호출하는 것이 아니라 단순히 <code>()</code>안의 값이 반환되고 <code>typeof</code>가 적용되는 것이다. <code>typeof</code>라는 함수는 <strong>없다</strong>.</p>
</aside>

</div><div><h3>JavaScript 타입 표</h3>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp("meow")  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>이 표에서 <em>Type</em>은 <code>typeof</code>가 반환하는 값이다. 표에서 본 것처럼 이 값은 계속 쓸모없다.</p>

<p>Class는 객체 내부에 있는 <code>[[Class]]</code> 프로퍼티의 값이다.</p>

<aside>
  <p><strong>표준</strong>에는 <code>[[Class]]</code>의 값은 <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>중 하나라고 나와있다.</p>
</aside>

<p><code>[[Class]]</code>의 값을 가져다 쓰려면 <code>Object.prototype</code>의 <code>toString</code> 메소드를 사용해야 한다.</p>

</div><div><h3>객체의 클래스</h3>

<p>표준에 의하면 <code>[[Class]]</code> 값을 얻는 방법은 <code>Object.prototype.toString</code> 하나뿐이다.</p>

<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true
</code></pre>

<p><code>Object.prototype.toString</code>은 <a href="#function.this">this</a>의 <code>[[Class]]</code> 값을 가져오는 것이니까 this를 obj로 바꾸어 사용한다.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> ECMAScript 5에서 <code>Object.prototype.toString</code>의 컨텍스트가 <code>null</code>과 <code>undefined</code>일 때 <code>Object</code>가 아니라 각각 <code>Null</code>과 <code>Undefined</code>를 반환하도록 수정됐다.</p>
</aside>

</div><div><h3>변수가 Undefined인지 확인하기</h3>

<pre><code>typeof foo !== &#39;undefined&#39;
</code></pre>

<p>이것은 <code>foo</code>가 정의됐는지 아닌지를 확인해준다. 정의되지 않은 변수에 접근하면 <code>ReferenceError</code> 나는데 이것을 방지할 수 있다. <code>typeof</code>가 유용한 건 이때뿐이다.</p>

</div><div><h3>결론</h3>

<p>객체의 타입을 검사하려면 <code>Object.prototype.toString</code>를 사용해야 한다. 다른 방법은 신뢰할 수 없다. 위 표에서 보여준 것처럼 typeof가 반환하는 값은 표준에 나와 있지 않기 때문에 구현마다 다르다.</p>

<p>변수가 정의됐는지 확인할 때는 빼고 <strong>목숨을 걸고</strong> <code>typeof</code>를 사용하지 못하게 해야 한다.</p></div></article><article id="types.instanceof"><h2><code>instanceof</code></h2><div><p><code>instanceof</code>는 두 객체의 생성자를 비교하는 것이고 직접 만든 타입의 객체를 비교할 때 유용하다. 기본 타입만 생각하면 이 연산자는 <a href="#types.typeof">typeof</a>처럼 거의 쓸모 없다.</p>

</div><div><h3>직접 만든 타입의 객체를 <code>intanceof</code>로 비교하기</h3>

<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// Bar.prototype에 function 객체인 Foo를 할당하면
// Bar의 인스턴스는 Foo의 인스턴스가 아니다.
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
</code></pre>

</div><div><h3>기본 타입 객체를 <code>intanceof</code>로 비교하기</h3>

<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false
</code></pre>

<p>JavaScript 컨텍스트마다(웹 브라우저의 도큐먼트 같은) 객체의 생성자는 다를 수밖에 없어서 <code>instanceof</code>는 다른 JavaScript 컨텍스트에 있는(웹 브라우저의 다른 도큐먼트에 있는) 객체와는 비교할 수 없다.</p>

</div><div><h3>결론</h3>

<p><code>instanceof</code>는 한 JavaScript 컨텍스트 내에서 사용자가 만든 타입의 객체를 비교할 때에만 유용하다. <a href="#types.typeof"><code>typeof</code></a>처럼 다른 목적으로는 사용하지 않는 것이 좋다.</p></div></article><article id="types.casting"><h2>Type Casting</h2><div><p>JavaScript는 Weak Typing 언어이기 때문에 필요할 때마다 알아서 타입을 변환한다.</p>

<pre><code>// 다음은 모두 true
new Number(10) == 10; // Number.toString()이 호출되고 
                      // 다시 Number로 변환된다.

10 == &#39;10&#39;;           // 스트링은 Number로 변환된다.
10 == &#39;+10 &#39;;         // 이상한 스트링
10 == &#39;010&#39;;          // 엉뚱한 스트링
isNaN(null) == false; // null은 NaN이 아녀서 0으로 변환된다.

// 다음은 모두 false
10 == 010;
10 == &#39;-10&#39;;
</code></pre>

<aside class="es5"><p><strong>ES5 Note:</strong> <code>0</code>으로 시작하는 숫자 리터럴은 8진수다. 하지만, ECMAScript 5의 strict 모드에서는 더는 8진수로 해석하지 않는다.</p>
</aside>

<p>이런 문제들은 <a href="#types.equality">strict equal operator</a>로 <strong>미리 방지해야</strong> 한다. 이 operator로 JavaScript의 많은 결점을 보완할 수 있지만, 아직도 weak typing 시스템 때문에 생기는 문제가 많다.</p>

</div><div><h3>기본 타입 생성자</h3>

<p><code>Number</code>나 <code>String</code> 같은 기본 타입들의 생성자는 <code>new</code> 키워드가 있을 때와 없을 때 다르게 동작한다.</p>

<pre><code>new Number(10) === 10;     // False, Object와 Number
Number(10) === 10;         // True, Number와 Number
new Number(10) + 0 === 10; // True, 타입을 자동으로 변환해주기 때문에 
</code></pre>

<p><code>new</code> 키워드와 함께 <code>Number</code> 같은 기본 타입의 생성자를 호출하면 객체를 생성하지만 <code>new</code> 없이 호출하면 형 변환만 시킨다.</p>

<p>그리고 객체가 아니라 단순히 값이나 리터럴을 사용하면 타입 변환이 더 많이 일어난다.</p>

<p>가능한 정확하게 타입을 변환해주는 것이 최선이다.</p>

</div><div><h3>스트링으로 변환하기</h3>

<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true
</code></pre>

<p>숫자를 빈 스트링과 더하면 쉽게 스트링으로 변환할 수 있다.</p>

</div><div><h3>숫자로 변환하기</h3>

<pre><code>+&#39;10&#39; === 10; // true
</code></pre>

<p><code>+</code> 연산자만 앞에 붙여주면 스트링을 쉽게 숫자로 변환할 수 있다.</p>

</div><div><h3>Boolean으로 변환하기</h3>

<p>&#39;!&#39; 연산자를 두 번 사용하면 쉽게 Boolean으로 변환할 수 있다.</p>

<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true
</code></pre></div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>핵심</h1></header><!-- Articles--><article id="core.eval"><h2>왜 <code>eval</code>을 사용하면 안 될까?</h2><div><p><code>eval</code> 함수는 스트링으로 된 JavaScript 코드를 Local Scope에서 실행한다.</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1
</code></pre>

<p><code>eval</code>을 <code>eval</code>이라는 이름으로 <strong>직접</strong> 직행할 때에만 Local Scope에서 실행된다.</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3
</code></pre>

<p>어쨌든 <code>eval</code>은 사용하지 말아야 한다. eval을 사용하는 경우의 99.9%는 사실 eval이 필요 없다.</p>

</div><div><h3>가짜 <code>eval</code></h3>

<p><a href="#other.timeouts"><code>setTimeout</code>과 <code>setInterval</code></a>은 첫 번째 인자로 스트링을 입력받을 수 있다. 이 경우에는 <code>eval</code>을 직접 호출하는 것이 아니라서 항상 Global Scope에서 실행된다.</p>

</div><div><h3>보안 이슈</h3>

<p><code>eval</code>은 보안 문제도 있다. 단순히 <strong>모든</strong> 코드를 실행하기 때문에 신뢰하지 못하는 코드가 <strong>절대로</strong> 포함되지 않도록 주의해야 한다.</p>

</div><div><h3>결론</h3>

<p><code>eval</code>은 사용하지 않는 게 좋다. <code>eval</code>을 사용하는 모든 코드는 성능, 보안, 버그 문제를 일으킬 수 있다. 만약 <code>eval</code>이 필요해지면 <em>설계를 변경</em>하여 <code>eval</code>이 필요 없게 만들어야 한다.</p></div></article><article id="core.undefined"><h2><code>undefined</code>와 <code>null</code></h2><div><p>JavaScript는 <code>nothing</code>을 두 가지로 표현할 수 있고 그중 <code>undefined</code>가 더 유용하다.</p>

</div><div><h3><code>undefined</code>도 변수</h3>

<p><code>undefined</code>는 <code>undefined</code>라는 값을 가지는 데이터 형식이다.</p>

<p><code>undefined</code>는 상수도 아니고 JavaScript의 키워드도 아니다. 그냥 <code>undefined</code>라는 이름의 Global 변수이고 이 변수에는 <code>undefined</code>라고 할당돼 있다. 그래서 이 Global 변수의 값을 쉽게 바꿀 수 있다.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> ECMAScript 5의 strict 모드에서는 <code>undefined</code>를 더는 바꿀 수 없도록 했다. 하지만 <code>undefined</code>라는 함수를 만들면 여전히 할당할 수 있다.</p>
</aside>

<p><code>undefined</code> 값이 반환될 때:</p>

<ul>
<li>global 변수 <code>undefined</code>에 접근할 때.</li>
<li>아직 초기화하지 않은 변수</li>
<li><code>return</code> 구문이 없는 함수는 <code>undefined</code>를 반환함.</li>
<li><code>return</code> 구문이 없는 함수는 <code>undefined</code>를 반환함.</li>
<li><code>return</code> 구문으로 아무것도 반환하지 않을 때.</li>
<li>없는 프로퍼티를 찾을 때.</li>
<li>함수 인자가 생략될 때.</li>
<li><code>undefined</code>가 할당된 모든 것.</li>
<li><code>void(expression)</code> 형식으로 된 표현</li>
</ul>

<aside>
  <p><strong>역주:</strong> 예를 들어 CoffeeScript Compliler는 CoffeeScript의 <code>undefined</code>를 JavaScript의 <code>void 0</code>로 컴파일한다.</p>
</aside>

</div><div><h3><code>undefined</code>가 바뀔 때를 대비하기</h3>

<p>global 변수 <code>undefined</code>는 <code>undefined</code>라는 객체를 가리키는 것뿐이기 때문에 새로운 값을 할당한다고 해도 <code>undefined</code>의 값 자체가 바뀌는 것이 아니다.</p>

<p>그래서 <code>undefined</code>와 비교하려면 먼저 <code>undefined</code>의 값을 찾아와야 한다.</p>

<p><code>undefined</code> 변수가 바뀔 때를 대비해서 <code>undefined</code>라는 변수를 인자로 받는 <a href="#function.scopes">anonymous wrapper</a>로 감싸고 아무런 인자를 넘기지 않는 꼼수를 사용한다. </p>

<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // Local Scope에 undefined를 만들어서
    // 원래 값을 가리키도록 했다.

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>wrapper 안에 변수를 새로 정의하는 방법으로도 같은 효과를 볼 수 있다.</p>

<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>이 두 방법의 차이는 minified했을 때 4바이트만큼 차이 난다는 것과 한쪽은 wrapper 안에 var 구문이 없다는 것밖에 없다. </p>

</div><div><h3><code>Null</code> 객체의 용도</h3>

<p>JavaScript 언어에서는 <code>undefined</code>를 다른 언어의 <em>null</em> 처럼 쓴다. 진짜 <code>null</code>은 그냥 데이터 타입 중 하나일 뿐이지 더도덜도 아니다.</p>

<p>JavaScript를 깊숙히 건드리는 것이 아니면 null 대신 <code>undefined</code>를 사용해도 된다(<code>Foo.prototype = null</code>같이 프로토타입 체인을 끊을 때는 null을 사용한다).</p></div></article><article id="core.semicolon"><h2>쎄미콜론을 자동으로 삽입해준다.</h2><div><p>JavaScript는 C와 문법이 비슷하지만, 꼭 코드에 쎄미콜론을 사용하도록 강제하지 않는다. 그래서 생략할 수 있다.</p>

<p>사실 JavaScript는 쎄미콜론이 꼭 있어야 하고 없으면 이해하지 못한다. 그래서 JavaScript 파서는 쎄미콜론이 없으면 <strong>자동으로</strong> 쎄미콜론을 추가한다. </p>

<pre><code>var foo = function() {
} // 쎄미콜론이 없으니 에러 난다.
test()
</code></pre>

<p>파서는 쎄미콜론을 삽입하고 다시 시도한다.</p>

<pre><code>var foo = function() {
}; // 에러가 없어짐.
test()
</code></pre>

<p>쎄미콜론을 자동으로 삽입한 것이 <strong>대표적인</strong> JavaScript 설계 오류다. 쎄미콜론 유무에 따라 <em>전혀</em> 다른 코드가 될 수 있다.</p>

</div><div><h3>어떻게 다를까?</h3>

<p>코드에 쎄미콜론이 없으면 파서가 어디에 넣을지 결정한다.</p>

<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)
</code></pre>

<p>파서는 이 코드에 쎄미콜론을 다음과 같이 삽입한다.</p>

<pre><code>(function(window, undefined) {
    function test(options) {

        // 쎄미콜론을 넣는 것이 아니라 줄을 합친다.
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- 여기

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        ); // &lt;- 여기

        return; // &lt;- 여기에 넣어서 그냥 반환시킨다.
        { // 파서는 단순 블럭이라고 생각하고

            // 단순한 레이블과 함수
            foo: function() {}
        }; // &lt;- 여기
    }
    window.test = test; // &lt;- 여기

// 이 줄도 합쳐진다.
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- 여기

})(window); //&lt;- 여기에 파서는 쎄미콜론을 넣는다.
</code></pre>

<aside>
  <p><strong>주의:</strong> JavaScript 파서는 new line 문자가 뒤따라 오는 return 구문을 제대로 처리하지 못한다. 자동으로 쎄미콜론을 넣는 것 자체의 문제는 아니지만 어쨌든 여전히 문제다.</p>
</aside>

<p>파서는 완전히 다른 코드로 만들어 버린다. 이것은 <strong>오류</strong>다.</p>

</div><div><h3>Parenthesis</h3>

<p>쎄미콜론 없이 괄호가 붙어 있으면 파서는 쎄미콜론을 넣지 않는다.</p>

<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})
</code></pre>

<p>파서는 다음과 같이 코드를 바꾼다.</p>

<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})
</code></pre>

<p><code>log</code> 함수가 함수를 반환할 가능성은 거의 없다. 아마도 <code>undefined is not a function</code>이라는 <code>TypeError</code>가 발생할 거다.</p>

</div><div><h3>결론</h3>

<p>쎄미콜론은 반드시 사용해야 한다. 그리고 <code>{}</code>도 생략하지 않고 꼭 사용하는 것이 좋다. 한 줄밖에 안 되는 <code>if</code> / <code>else</code> 블럭에서도 꼭 사용해야 한다. 이 두 가지 규칙을 잘 지키면 JavaScript 파서가 잘못 해석하는 일을 미리 방지하고 코드도 튼튼해진다.</p></div></article><article id="core.delete"><h2><code>delete</code></h2><div><p>간단히 말해서 global 변수, Function, 등은 <code>DontDelete</code> 속성이기 때문에 delete하지 못 한다.</p>

</div><div><h3>Global 코드와 Function 코드</h3>

<p>Global이나 Function Scope에 정의한 Fuction이나 변수는 모두 Activation 객체나 Global 객체의 프로퍼티다. 이 프로퍼티는 모두 <code>DontDelete</code> 속성을 가진다. Global이나 Function 코드에서 변수나 Function의 정의하면 항상 <code>DontDelete</code> 프로퍼티로 만들어진다. 그러니까 delete할 수 없다:</p>

<pre><code>// Global 변수:
var a = 1; // DontDelete가 설정된다.
delete a; // false
a; // 1

// Function:
function f() {} // DontDelete가 설정된다.
delete f; // false
typeof f; // "function"

// 다시 할당해도 삭제할 수 없다:
f = 1;
delete f; // false
f; // 1
</code></pre>

</div><div><h3>Explicit 프로퍼티</h3>

<p>다음 예제에서 만드는 프로퍼티는 delete할 수 있다. 이런 걸 Explicit 프로퍼티라고 부른다:</p>

<pre><code>// Explicit 프로퍼티를 만든다:
var obj = {x: 1};
obj.y = 2;
delete obj.x; // true
delete obj.y; // true
obj.x; // undefined
obj.y; // undefined
</code></pre>

<p><code>obj.x</code>와 <code>obj.y</code>는 <code>DontDelete</code> 속성이 아니라서 delete할 수 있다. 그러나 다음과 같은 코드도 잘 동작하기 때문에 헷갈린다:</p>

<pre><code>// IE를 빼고 잘 동작한다:
var GLOBAL_OBJECT = this;
GLOBAL_OBJECT.a = 1;
a === GLOBAL_OBJECT.a; // true - 진짜 Global 변수인지 확인하는 것
delete GLOBAL_OBJECT.a; // true
GLOBAL_OBJECT.a; // undefined
</code></pre>

<p><a href="#function.this"><code>this</code></a>가 Global 객체를 가리키는 것을 이용해서 명시적으로 프로퍼티 <code>a</code>를 선언하면 삭제할 수 있다. 이것은 꼼수다.</p>

<p>IE (적어도 6-8)는 버그가 있어서 안 된다.</p>

</div><div><h3>Argument들과 Function의 기본 프로퍼티</h3>

<p>Function의 <a href="#function.arguments"><code>arguments</code> 객체</a>와 기본 프로퍼티도 <code>DontDelete</code> 속성이다.</p>

<pre><code>// Function의 arguments와 프로퍼티:
(function (x) {

  delete arguments; // false
  typeof arguments; // "object"

  delete x; // false
  x; // 1

  function f(){}
  delete f.length; // false
  typeof f.length; // "number"

})(1);
</code></pre>

</div><div><h3>Host 객체</h3>

<aside>
  <p><strong>역주:</strong> Host 객체는 document같은 DOM 객체를 말한다.</p>
</aside>

<p>Host 객체를 delete하면 어떻게 될지 알 수 없다. 표준에는 어떻게 Host 객체를 delete해야 하는지 정의하지 않았다.</p>

</div><div><h3>결론</h3>

<p><code>delete</code> 연산자는 엉뚱하게 동작할 때가 잦다. 명시적으로 정의한 일반 객체의 프로퍼티만 delete하는 것이 안전하다.</p></div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>기타</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code>과 <code>setInterval</code></h2><div><p>JavaScript는 비동기이기 때문에 <code>setTimeout</code>과 <code>setInterval</code> 로 함수의 실행 순서를 조절할 수 있다.</p>

<aside>
  <p><strong>Note:</strong> Timeout은 ECMAScript 표준이 아니라 <a href="http://en.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a>때문에 구현됐다.</p>
</aside>

<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // 0보다 큰 수를 반환한다.
</code></pre>

<p><code>setTimeout</code>을 호출하면 timeout의 ID를 반환하고 <strong>대충</strong> 1,000밀리 초 후에 <code>foo</code>를 실행시킨다. <code>foo</code>는 <strong>딱 한 번만</strong> 실행한다.</p>

<p>JavaScript 엔진의 단위 시간(timer resolution)에 따라서 코드를 실행시키고 단일 쓰레드인 JavaScript를 특정 코드가 블록 시켜 버릴 수도 있기 때문에 <code>setTimeout</code>으로 코드가 실행돼야 할 시간을 정해줘도 <strong>정확하게 그 시간에 실행되지 않는다.</strong>.</p>

<p>첫 번째 인자로 넘긴 함수가 실행될 때 컨텍스트인 <a href="#function.this"><code>this</code></a>는 <em>Global</em> 객체를 가리킨다.</p>

<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this는 Global 객체를 가리키기 때문에 
        console.log(this.value); // undefined를 출력한다.
    };
    setTimeout(this.method, 500);
}
new Foo();
</code></pre>

<aside>
  <p><strong>Note:</strong> <code>setTimeout</code>의 첫 번째 파라미터에 <strong>함수</strong> 객체를 넘겨야 하는 데 <code>setTimeout(foo(), 1000)</code>처럼 함수의 실행 결과를 넘기는 실수를 저지를 때가 잦다. 이럴 때 <code>setTimeout</code>은 그냥 <code>undefined</code>를 반환할 뿐이지 에러를 발생시키지 않는다.</p>
</aside>

</div><div><h3><code>setInterval</code>은 계속 함수 호출을 쌓는다(Stacking).</h3>

<p><code>setTimeout</code>은 딱 한 번 함수를 호출하지만 <code>setInterval</code>은 이름처럼 <strong>지정한 시간마다</strong> 함수를 실행해 준다. 이 <code>setInterval</code>은 별로다.</p>

<p>만약 실행하는 코드가 일정시간 동안 블럭되도 <code>setInterval</code>은 계속 함수를 호출시키려 든다. 특히 주기가 짧으면 밀리기 쉬워서 함수 호출은 계속 쌓일 수 있다.</p>

<pre><code>function foo(){
    // 1초 동안 블럭함.
}
setInterval(foo, 1000);
</code></pre>

<p><code>foo</code>는 단순히 호출될 때마다 1초 동안 블럭하는 함수다.</p>

<p><code>foo</code>가 블럭해도 <code>setInterval</code>은 계속 함수 호출을 쌓는다. <code>foo</code>의 첫 번째 호출이 끝나도 <em>10번</em> 이상의 함수 호출이 쌓여 대기하고 있다.</p>

</div><div><h3>오래 걸리는 코드 다루기</h3>

<p><code>setTimeout</code> 으로 함수 자신을 호출하는 방법으로 해결하기가 가장 쉽다.</p>

<pre><code>function foo(){
    // something that blocks for 1 second
    setTimeout(foo, 1000);
}
foo();
</code></pre>

<p>함수 호출이 쌓이지도 않을 뿐만 아니라 <code>setTimeout</code> 호출을 해당 함수 안에서 관리하고 <code>foo</code> 함수에서 계속 실행할지 말지 조절할 수도 있다.</p>

</div><div><h3>Timeout 없애기</h3>

<p><code>clearTimeout</code>과 <code>clearInterval</code> 함수로 setTimeout과 setInterval로 등록한 timeout과 interval을 삭제할 수 있다. <code>set</code> 함수들이 반환한 id를 저장했다가 <code>clear</code> 함수를 호출하여 삭제한다.</p>

<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);
</code></pre>

</div><div><h3>timeout을 전부 없애기</h3>

<p>등록한 timeout과 interval을 한꺼번에 제거하는 메소드는 없다. 구현해서 사용해야 한다.</p>

<pre><code>// clear "all" timeouts
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}
</code></pre>

<p>Id가 1부터 1000 사이에 있는 timeout들을 제거했지만, 그 외의 것은 아직 남아있다. 또 다른 방법이 있다. <code>setTimeout</code>은 항상 호출될 때마다 전보다 1만큼 큰 수를 ID로 반환한다. 이 점을 이용해 1부터 가장최근 ID까지 모두 삭제할 수 있다.</p>

<pre><code>// clear "all" timeouts
var biggestTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= biggestTimeoutId; i++) {
    clearTimeout(i);
}
</code></pre>

<p>이 방법은 모든 주요 브라우저에서 문제없이 잘 동작한다. 하지만 ID가 항상 순차적이어야 한다고 표준에 명시된 것이 아니다. 그러므로 timeout ID를 모두 저장했다가 삭제하는 것이 가장 안전하다. 그러면 전부 깨끗하게 제거할 수 있다.</p>

</div><div><h3>숨겨진 <code>eval</code></h3>

<p><code>setTimeout</code>과 <code>setInterval</code>의 첫 파라미터에 스트링도 넘길 수 있다. 그렇지만, 내부적으로 <code>eval</code>을 사용하는 것이기 때문에 절대 사용하지 말아야 한다.</p>

<aside>
  <p><strong>Note:</strong> timeout 함수는 ECMAScript 표준이 아녀서 첫 인자가 스트링 타입일 때에는 JavaScript 구현체마다 다르게 동작한다. 예를 들어, Microsoft의 JScript는 <code>eval</code>이 아니라 <code>Function</code> 생성자를 사용한다.</p>
</aside>

<pre><code>function foo() {
    // 이게 호출됨
}

function bar() {
    function foo() {
        // 이것은 절대 호출 안 됨
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();
</code></pre>

<p>이 경우 <code>eval</code>이 <a href="#core.eval">그냥(directly)</a> 호출되는 것이 아니다. <code>setTimeout</code>에 넘겨진 스트링은 <em>Global</em> Scope에서 실행되기 때문에 <code>bar</code>의 Local 함수 <code>foo</code>가 실행되는 것이 아니라 <em>Global</em> Scope의 <code>foo</code>가 실행된다.</p>

<p>함수에 파라미터를 넘겨야 하면 스트링을 사용하지 말아야 한다.</p>

<pre><code>function foo(a, b, c) {}

// 절대 사용하면 안 됨
setTimeout(&#39;foo(1,2, 3)&#39;, 1000)

// 대신 익명 함수를 사용하는 게 좋다.
setTimeout(function() {
    foo(a, b, c);
}, 1000)
</code></pre>

<aside>
  <p><strong>Note:</strong> <code>setTimeout(foo, 1000, a, b, c)</code>처럼 사용하는 것도 가능하지만, 이것도 권장하지 않는다. 메소드를 사용할 때 미묘한 에러가 날 수 있다.</p>
</aside>

</div><div><h3>결론</h3>

<p><code>setTimeout</code>과 <code>setInterval</code>의 파라미터로 스트링은 절대 사용하지 말아야 한다. 핸들러 함수에 인자를 넘겨야 하는 경우도 <strong>분명히</strong> 탈 난다. <em>익명 함수</em>을 사용해서 호출해야 한다.</p>

<p>그리고 <code>setInterval</code>은 해당 핸들러가 블럭되든 말든 상관하지 않기 때문에 사용하면 안 된다.</p></div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with 
<a href="http://nodejs.org/">Node.js </a>using a
<a href="https://github.com/visionmedia/jade/">jade </a>template. 
Hosted by 
<a href="http://pages.github.com/">gh-pages</a>create by 
<a href="http://webqss.inter.iqiyi.com/">qss</a>.
</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="../javascript/prettify.js"></script><script src="../javascript/plugin.js"></script><script src="../javascript/garden.js"></script></body></html>